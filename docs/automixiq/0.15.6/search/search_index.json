{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AutomixIQ","text":"<p>Enable smooth transitions between tracks for a seamlessly beat-matched experience within your Android music application.</p>"},{"location":"#overview","title":"Overview","text":"<p>AutomixIQ is a framework that exposes a music player which analyzes tracks in your application. It offers machine-learned transitions between tracks and when seeking, essentially serving as an automated DJ for your music. The framework determines the ideal points in each song to smoothly transition to the next, synchronizing beats and matching keys.</p> <p>This documentation provides a step-by-step guide on how to get started with using the AutomixIQ in your application.</p> <p> </p>"},{"location":"API-reference/","title":"API Reference","text":"<p>You can find the documentation of available APIs here: AutomixIQ API Reference</p>"},{"location":"Access-waveform-data/","title":"Access waveform data","text":""},{"location":"Access-waveform-data/#overview","title":"Overview","text":"<p>As AutomixIQ analyses tracks to generate transitions, it also makes waveform data available to be accessed by the client application for rendering on screen.</p> <p>Once data is available, the <code>onWaveformDataAvailable</code> method in <code>AutomixIQStatusListener</code> will be invoked.</p> <p>See Implement status listener.</p>"},{"location":"Access-waveform-data/#setting-resolution","title":"Setting resolution","text":"<p>The resolution of the waveform data can be set with a maximum of 1024 points (defaults to 256)</p> <pre><code>val waveformResolution: Int = myWaveformResolution      // default 256, maximum 1024\n\nAutomixIQ.getInstance()?.setWaveformPointsPerTrack(waveformResolution)\n</code></pre>"},{"location":"Access-waveform-data/#accessing-placeholder-data","title":"Accessing placeholder data","text":"<p>The placeholder waveform data is accessible whilst AutomixIQ is analysing the track and does not have the waveform data ready.</p> <pre><code>val placeholderWaveform = AutomixIQ.getInstance()?.placeholderWaveformDataForTrack(trackId)\n</code></pre> <p>The above function returns AutomixIQWaveformModel.</p>"},{"location":"Access-waveform-data/#accessing-waveform-data","title":"Accessing waveform data","text":"<p>The waveform data will be ready once AutomixIQ has finished analysing the track.</p> <pre><code>val waveform = AutomixIQ.getInstance()?.waveformDataForTrack(trackId, applyEnterTransition = true, applyExitTransition = true)\n</code></pre> <p>The above function returns AutomixIQWaveformModel.</p>"},{"location":"Audio-file-requirements/","title":"Audio file requirements","text":"<p>For efficient mixing with streamed audio, AutomixIQ requires that the audio is stored in a format that supports sample-accurate real-time seeking with only partial file downloads. In practice, this means that formats with a fine-grained seek table are preferred. The only common compressed audio file format that meets these requirements is AAC audio contained in the MPEG-4 file format, typically with <code>mp4</code> or <code>m4a</code> file extensions.</p> <p>There are two distinct families of audio formats:</p> <ul> <li> <p>Formats with integrated encoding and file structure:</p> <ul> <li>Example: mp3 files.</li> <li>These formats do not separate the packets of encoded audio from the file structure.</li> </ul> </li> <li> <p>Formats with separated container and audio packets:</p> <ul> <li>Example: Ogg/Vorbis.</li> <li>These formats separate the container (e.g., Ogg) from the format of the audio packets (e.g., Vorbis).</li> </ul> </li> </ul> <p>Due to this separation, some audio compression standards like AAC may or may not support the above requirements, depending on the container format. ADTS containers, for example, require scanning the entire file to construct a seek table and are not preferred, but they are included to support mislabeled AAC files.</p>"},{"location":"Audio-file-requirements/#with-tuned-global-backend","title":"With Tuned Global Backend","text":"<p>The <code>high</code> quality audio setting is designed to work with AutomixIQ.</p> <p>Please make sure the user's audio quality is set to <code>high</code> before loading any tracks into AutomixIQ's player.</p>"},{"location":"Audio-file-requirements/#with-custom-backend","title":"With custom backend","text":"<p>The default configuration of AutomixIQ supports AAC-LC in MPEG-4 or ADTS containers.</p> <p>Upon request, AutomixIQ can be configured to support additional file formats. These formats include MP3, Opus, Vorbis, FLAC, and ALAC decoders, as well as Ogg and CAF containers.</p>"},{"location":"Change-log/","title":"Change Log","text":"<p>This is a beta build - No change log available at the moment.</p>"},{"location":"Configure-the-SDK-custom/","title":"Configure the SDK with custom backend","text":""},{"location":"Configure-the-SDK-custom/#overview","title":"Overview","text":"<p>This document explains how to integrate AutomixIQ with your application you are using a custom backend to access tracks and metadata.</p> <p>To initialise AutomixIQ when you take the responsibility of providing audio data and metadata you need:</p> <ul> <li>A store ID and an application ID provided by the Tuned Global team</li> <li>An implementation of the <code>AutomixIQStreamingListener</code> interface</li> </ul>"},{"location":"Configure-the-SDK-custom/#implement-your-automixiqstreaminglistener","title":"Implement your AutomixIQStreamingListener","text":"<p><code>AutomixIQStreamingListener</code> is an interface that provides AutomixIQ with the essential information from your service to support playback. Extend the <code>AutomixIQStreamingListener</code> class and implement the required functions as shown below:</p> <ul> <li>isLoggedIn</li> <li>asyncCheckDeviceStatus</li> <li>getDeviceIdentifier</li> <li>syncGetTrackMetadata</li> <li>syncGetCachedTrack</li> <li>cacheMetadata</li> <li>asyncGetTrackMetadata</li> <li>asyncLogPlayEvent</li> <li>asyncGetStream</li> <li>onTrackDownloadCompeleted</li> <li>onTrackDownloadProgressChanged</li> </ul> <p>You can find a detailed explanation in API Reference</p> <pre><code>public class MyAutomixIQStreamingListener: AutomixIQStreamingListener {\n\n    // Return whether the user is logged in\n    override fun isLoggedIn() {\n        return this.loggedIn\n    }\n\n    // Query and inform whether the device is allowed to continue playing by calling onComplete/onError\n    override fun asyncCheckDeviceStatus(onComplete: ((Boolean) -&gt; Unit)?,\n                                        onError: ((AutomixIQError) -&gt; Unit)?) -&gt; Unit) {\n        this.canDeviceContinuePlaying() { allowedToPlay -&gt;\n            onComplete(allowedToPlay)\n        }\n    }\n\n    // Return this device's unique identifier\n    override fun getDeviceIdentifier(): String? {\n        return this.deviceIdentifier\n    }\n\n    // Return the track metadata if available offline or cached\n    override fun syncGetTrackMetadata(trackId: String?): AutomixIQTrackModel? {\n        // If this track is cached, return its metadata\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.metadataForTrack(trackId)\n    }\n\n    // Return the track data if available offline or cached \n    override fun syncGetCachedTrack(trackId: String): ByteArray? {\n        // If this track is cached, return its data\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.unencryptedDataForTrack(trackId)\n    }\n\n    // Cache this metadata for later use\n    override fun cacheMetadata(metadata: List&lt;AutomixIQTrackModel&gt;) {\n        this.metadataForTrack[metadata.trackId] = metadata\n    }\n\n    // Download the track metadata and return it to AutomixIQ by running onComplete/onError\n    override fun asyncGetTrackMetadata(trackId: String,\n                                       onComplete: ((AutomixIQTrackModel) -&gt; Unit)?,\n                                       onError: ((AutomixIQError) -&gt; Unit)?) -&gt; Unit) {\n        this.getTrackMetadata(trackId) { error, trackMetadata -&gt;\n            val automixIQTrackModel = translateMetadata(trackMetadata)\n            if (error != null) {\n                onError(error)\n                return@getTrackMetadata\n            }\n            onComplete(automixIQTrackModel)\n            return@getTrackMetadata\n        }\n    }\n\n    // If we need to report playback, do so\n    override fun asyncLogPlayEvent(trackId: String, seconds: Int, guid: String, logPlayType: String,\n                                   onComplete: (() -&gt; Unit)?,\n                                   onError: ((AutomixIQError) -&gt; Unit)?) {\n        val deviceId = myDeviceIdentifier\n        if(deviceId == null) {\n            onError?.invoke(AutomixIQError.NOT_LOGGED_IN)\n            return\n        }\n\n        this.logPlay(deviceId, trackId, seconds, guid, logPlayType, completion = { error -&gt;\n            if(error != null) {\n                onError?.invoke(error)\n                return@postLogPlay\n            }\n\n            onComplete?.invoke()\n        })\n    }\n\n    // Retrieve the track's url, and return it to AutomixIQ by running onComplete/onError\n    override fun asyncGetStream(streamingDeviceId: String, sessionId: String, trackId: String, \n                                onComplete: ((String /* URL */, String? /* newSessionId */) -&gt; Unit)?,\n                                onError: ((AutomixIQError) -&gt; Unit)?) {\n        this.getTrackURL(streamingDeviceId, sessionId, trackId) { error, url, newSessionId -&gt;\n            if (error != null) {\n                onError(error)\n                return@getTrackURL\n            }\n            onComplete(url, newSessionId, null)\n        }\n    }\n\n    // AutomixIQ will return the audio data once a download is completed\n    override fun onTrackDownloadCompeleted(trackId: String, data: ByteArray) {\n        this.cacheTrack(trackId, data)\n    }\n\n    // Monitor the download progress (0 to 1)\n    override fun onTrackDownloadProgressChanged(trackId: String, progress: Float) {\n        this.updateTrackDownloadProgress(trackId, progress)\n    }\n}\n</code></pre> <p>Do keep in mind that AutomixIQ downloads tracks lazily as it requires data for analysis / playback. There is no guarantee a track will be fully downloaded if the track is not played in its entirety.</p>"},{"location":"Configure-the-SDK-custom/#initialise-automixiq-instance","title":"Initialise AutomixIQ instance","text":"<p>Create an <code>AutomixIQConfig</code> first. You can get the store ID, application ID from the Tuned Global team.</p> <pre><code>val automixConfig = \n    AutomixIQConfig.Builder()\n        .apiKey(myAPIKey)\n        .country(myCountryISO2Code) // Device country code e.g. \"US\", \"AU\"\n        .storeId(myTunedStoreId )\n        .applicationId(myTunedApplicationId)\n        .logLevel(AutomixIQLogLevel.DEBUG)\n        .build()\n</code></pre> <p>Initialise the AutomixIQ instance with the <code>AutomixIQStreamingListener</code> and <code>AutomixIQConfig</code> created in previous steps. We recommend initialising the SDK once your music background service is up and running.</p> <p>Note</p> <p>AutomixIQ requires an active internet connection for its initial verification. After this initial setup, it can be initialised offline. However, note that there is a grace period of 7 days, after which an internet connection will be required again for re-verification.</p> <pre><code>    AutomixIQ.initialise(applicationContext,\n                         automixIQStreamingListener,\n                         config,\n                         onComplete = \n    { _ -&gt; \n        // The AutomixIQ public functions can be used from this point onwards :)\n\n        // We can add a status listener to get UI updates and play events\n        val automixIQStatusListener: AutomixIQStatusListener = myAutomixIQStatusListener\n        AutomixIQ.getInstance()?.addStatusListener(automixIQStatusListener)\n\n        // ...\n    }, onError = { error, _ -&gt;\n        // This means you are forbidden to use the AutomixIQ or you have no internet connection.\n    })\n</code></pre>"},{"location":"Configure-the-SDK-custom/#implement-automixiqstatuslistener-optional","title":"Implement AutomixIQStatusListener (Optional)","text":"<p>The <code>AutomixIQStatusListener</code> is responsible for updating your player\u2019s UI, please refer to Update UI</p>"},{"location":"Configure-the-SDK-custom/#check-initialised-state","title":"Check initialised state","text":"<p>To check whether AutomixIQ is initialised </p> <pre><code>AutomixIQ.getInstance()?.initialised()\n</code></pre>"},{"location":"Configure-the-SDK-custom/#shut-down","title":"Shut down","text":"<p>To shut down AutomixIQ</p> <pre><code>AutomixIQ.terminate()\n</code></pre> <p>After you have terminated the SDK, you will need to reinitialise if you want to use AutomixIQ again.</p>"},{"location":"Configure-the-SDK-tuned/","title":"Configure the SDK with Tuned Global backend","text":""},{"location":"Configure-the-SDK-tuned/#overview","title":"Overview","text":"<p>This document explains how to integrate AutomixIQ with your application if it is already using Tuned Global\u2019s backend to access tracks and metadata.</p> <p>To initialise AutomixIQ with Tuned Global's API and services, you need </p> <ul> <li>A store ID and an application ID provided by the Tuned Global team</li> <li>An implementation of the <code>AutomixIQTunedRestHook</code> interface</li> </ul>"},{"location":"Configure-the-SDK-tuned/#implement-your-automixiqtunedresthook","title":"Implement your AutomixIQTunedRestHook","text":"<p><code>AutomixIQTunedRestHook</code> is an interface that facilitates communication between the Tuned Global Backend and the AutomixIQ SDK regarding the user's access token and device information. Extend the <code>AutomixIQTunedRestHook</code> class and implement the required functions as shown below:</p> <ul> <li>getAuthenticatedDevice</li> <li>getUniqueDeviceIdentifier</li> <li>onTunedRestTokenExpired</li> </ul> <p>You can find a detailed explanation in API Reference</p> <pre><code>class MyTunedRestHook: AutomixIQTunedRestHook {\n\n    // Return the Tuned API device ID integer\n    override suspend fun getAuthenticatedDevice(uniqueDeviceIdentifier: String): String? {\n        val myTunedDeviceId: String = tunedDeviceId\n        return myTunedDeviceId\n    }\n\n    // Return an ID that can be used to identify a device.\n    // This is typically a randomly generated UUID that persists through app restarts.\n    override fun getUniqueDeviceIdentifier(): String {\n        val uuid: String = myUniqueDeviceIdentifier\n        return uuid\n    }\n\n    // Use the info provided from the parameters to refresh the Tuned user token\n    override suspend fun onTunedRestTokenExpired(uniqueDeviceIdentifier: String,\n                                                 countryCode: String,\n                                                 tunedUserId: String?,\n                                                 oldAccessToken: String?,\n                                                 refreshToken: String?,\n                                                 tokenType: String?): TunedAuthenticationResponse? {\n        // your implementation of refreshing Tuned user token\n        val tunedAuthenticationResponse: TunedAuthenticationResponse? = null\n        withContext(Dispatchers.IO) {\n            suspendCancellableCoroutine { continuation -&gt;\n                refreshToken(refreshToken, tokenType, uniqueDeviceIdentifier) { authToken, tokenType, tokenExpiration, refreshToken -&gt;\n                    val userId = tunedUserId\n                    tunedAuthenticationResponse = TunedAuthenticationResponse(authToken,\n                                                                              tokenType,\n                                                                              tokenExpiration,\n                                                                              refreshToken,\n                                                                              tunedUserId)\n                    continuation.resume(Unit)\n                }\n            }\n        }\n        return tunedAuthenticationResponse\n    }\n}\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#initialise-automixiq-instance","title":"Initialise AutomixIQ instance","text":"<p>Create an <code>AutomixIQConfig</code> first. The store and application ID will be provided by the Tuned Global team.</p> <pre><code>val automixConfig = \n    AutomixIQConfig.Builder()\n        .apiKey(myAPIKey)\n        .country(myCountryISO2Code) // Device country code e.g. \"US\", \"AU\"\n        .storeId(myTunedStoreId )\n        .applicationId(myTunedApplicationId)\n        .logLevel(AutomixIQLogLevel.DEBUG)\n        .automaticallyLogPlayback(false)\n        .build()\n</code></pre> <p>Initialise the AutomixIQ instance with the <code>AutomixIQTunedRestHook</code> and <code>AutomixIQConfig</code> created in previous steps. We recommend initialising the SDK once your music background service is up and running.</p> <p>Note</p> <p>AutomixIQ requires an active internet connection for its initial verification. After this initial setup, it can be initialised offline. However, note that there is a grace period of 7 days, after which an internet connection will be required again for re-verification.</p> <pre><code>    AutomixIQ.initialise(applicationContext,\n                         myTunedRestHook,\n                         automixConfig,\n                         onComplete = { automixStatus -&gt;\n\n        // The AutomixIQ public functions can be used from this point onwards :)\n\n        // We can set a music cache hook if we want to support offline playback\n        val musicCacheHook: AutomixIQTunedMusicCacheHook = myMusicCacheHook\n        AutomixIQ.getInstance()?.setMusicCacheHook(musicCacheHook)\n\n        // We can add a status listener to get UI updates and play events, you can add as many AutomixIQStatusListener as you like\n        val automixIQStatusListener: AutomixIQStatusListener = myAutomixIQStatusListener\n        AutomixIQ.getInstance()?.addStatusListener(automixIQStatusListener)\n\n        // ...\n    }, onError = { automixIQError, automixIQStatus -&gt; \n        // This means you do not have permission to use AutomixIQ or there is no internet connection when required.\n        return\n    })\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#implement-automixiqtunedmusiccachehook-optional","title":"Implement AutomixIQTunedMusicCacheHook (Optional)","text":"<p>AutomixIQ supports offline playback using local music data. You can implement the <code>AutomixIQTunedMusicCacheHook</code> to</p> <ul> <li>provide track metadata and cached audio data,</li> <li>extract audio data downloaded by AutomixIQ</li> <li>monitor the download progress</li> </ul> <p>This approach enhances efficiency and prevents AutomixIQ from having to request this data from Tuned Global\u2019s API if they are already available. This also enables offline playback when all the required data is available locally. </p> <p>Implement the <code>AutomixIQTunedMusicCacheHook</code> and add it to the SDK after initialisation. You can find a detailed explanation in API Reference</p> SetMusicCacheHook<pre><code>AutomixIQ.getInstance()?.setMusicCacheHook(MyMusicCacheHook())\n</code></pre> MyMusicCacheHook<pre><code>public class MyMusicCacheHook: AutomixIQTunedMusicCacheHook {\n\n    // Provide the track metadata. For offline playback, this is required if the metadata is not loaded when playing tracks.\n    override fun getTrackMetadata(trackId: String?): AutomixIQTrackModel? {\n        // If the track is not cached, return null and AutomixIQ will try to fetch it.\n        if (!isTrackCached(trackId)) {\n            return null\n        }\n        return metadataForTrack(trackId)\n    }\n\n    // Provide the cached audio data. For offline playback, this is required.\n    override fun getCachedTrack(trackId: String): ByteArray? {\n        // If the track is not cached, return null and AutomixIQ will try to stream it.\n        if (!isTrackCached(trackId)) {\n            return null\n        }\n\n        return rawAudioDataForTrack(trackId)\n    }\n\n    // AutomixIQ will \n    // - stream and download the tracks when they are not provided from `getCachedTrack` and call this method once the download for each track has completed\n    // - use the cached audio data from getCachedTrack and call this method once the data provided is verified for each track\n    override fun onTrackDownloadCompeleted(trackId: String, data: ByteArray) {\n        cacheTrack(trackId, data)\n    }\n\n    // Monitor the download progress (0 to 1)\n    override fun onTrackDownloadProgressChanged(trackId: String, progress: Float) {\n        updateTrackBufferingProgress(trackId, progress)\n    }\n}\n</code></pre> <p>Note</p> <p>If the byte data for a track provided through <code>getCachedTrack</code> does not fit the Audio file requirements. AutomixIQ will try to stream the track from the connected backend.</p>"},{"location":"Configure-the-SDK-tuned/#implement-automixiqstatuslistener-optional","title":"Implement AutomixIQStatusListener (Optional)","text":"<p>The <code>AutomixIQStatusListener</code> is responsible for updating your player\u2019s UI, please refer to Update UI</p>"},{"location":"Configure-the-SDK-tuned/#check-initialised-state","title":"Check initialised state","text":"<p>To check whether AutomixIQ is initialised </p> <pre><code>AutomixIQ.getInstance()?.initialised()\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#shut-down","title":"Shut down","text":"<p>To shut down AutomixIQ</p> <pre><code>AutomixIQ.terminate()\n</code></pre> <p>After you have terminated the SDK, you will need to reinitialise if you want to use AutomixIQ again.</p>"},{"location":"Control-playback/","title":"Control playback","text":"<p>AutomixIQ's player needs to be turned on before using any of the following playback controls API, see Turn AutomixIQ on and off. </p> <p>Use the <code>AutomixIQ</code> instance to control playback.</p> <pre><code>AutomixIQ.getInstance()\n</code></pre> <p>Playback control APIs include:</p> <ul> <li>Load tracks</li> <li>Add track</li> <li>Add tracks</li> <li>Remove track</li> <li>Move track</li> <li>Reorder tracks (Shuffle)</li> <li>Clear playlist</li> <li>Play</li> <li>Pause</li> <li>Next</li> <li>Previous</li> <li>Skip to a track</li> <li>Back</li> <li>Seek</li> <li>Loop track</li> <li>Stop looping track</li> <li>Force pause after playback of current track</li> </ul>"},{"location":"Control-playback/#load-tracks","title":"Load tracks","text":"<p>Loads a new set of tracks into the AutomixIQ player, it will override the currently loaded playlist.</p> <p>Note</p> <p>Please make sure you adhere to the Audio file requirements before loading any tracks to AutomixIQ</p> <pre><code>val identifiers: List&lt;String&gt; = myPlaylist \nval metadataList: List&lt;AutomixIQTrackModel&gt; = mySetOfMetadata\nval index = myPlaylistIndex\nval startPositionSeconds = myTrackStartPosition\nval contextType: String = myContextType\nval contextId: String = myContextId\n\nAutomixIQ.getInstance()?.loadTracks(\n    identifiers = identifiers,\n    metadata = metadataList,\n    playTrackIndex = index.coerceAtLeast(0),\n    seconds = startPositionSeconds,\n    autoplay = true,\n    contextType = contextType,      // for reporting purposes\n    contextId = contextId,          // for reporting purposes\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#add-track","title":"Add track","text":"<p>Add a track to the current playlist at a given index</p> <pre><code>val trackId: String = myTrackId\nval trackMetadata: AutomixIQTrackModel = myTrackMetadata\nval index = myIndexToAddTrack\n\nAutomixIQ.getInstance()?.addTrack(trackId, trackMetadata, index, \n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#add-tracks","title":"Add tracks","text":"<p>Add a list of tracks to the current playlist at a given index</p> <pre><code>val trackIds: List&lt;String&gt; = myTrackIds\nval metadata: List&lt;AutomixIQTrackModel&gt; = mySetOfMetadata\nval index = myIndexToAddTracks\n\nAutomixIQ.getInstance()?.addTracks(trackIds, metadata, index,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQsStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#remove-track","title":"Remove track","text":"<p>Remove a single track at a given index from the current playlist</p> <pre><code>val index = myIndexToRemove\n\nAutomixIQ.getInstance()?.removeTrack(index,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#move-track","title":"Move track","text":"<p>Move a single track within the current playlist</p> <pre><code>val fromIndex = myIndexToMoveFrom\nval toIndex = myIndexToMoveto\n\nAutomixIQ.getInstance()?.moveTrack(fromIndex, toIndex,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#reorder-tracks-shuffle","title":"Reorder tracks (Shuffle)","text":"<p>Reorder the sequence of the tracks in the current playlist. Use this API to implement shuffle playback. </p> <pre><code>val newOrder: List&lt;String&gt; = identifiersInNewOrder\n\nAutomixIQ.getInstance()?.reorderTracks(newOrder,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#clear-playlist","title":"Clear playlist","text":"<p>Clears the playlist loaded in AutomixIQ's player, which also stops music playback.</p> <pre><code>AutomixIQ.getInstance()?.resetPlaylistToEmpty(\n    onComplete = { automixIQStatus -&gt; \n        // Success\n    }, onError = automixIQError, automixIQStatus -&gt; {\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#play","title":"Play","text":"<p>Start or resume playback when the player is paused, returns error if <code>PLAYING</code> is true or <code>CAN_PLAY_PAUSE</code> is false</p> <pre><code>AutomixIQ.getInstance()?.play(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#pause","title":"Pause","text":"<p>Pause playback when the player is playing, returns error if <code>PLAYING</code> is false or <code>CAN_PLAY_PAUSE</code> is false</p> <pre><code>AutomixIQ.getInstance()?.pause(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#next","title":"Next","text":"<p>Skip to the next track in the playlist, returns error if <code>CAN_SKIP_TO_NEXT</code> is false</p> <pre><code>AutomixIQ.getInstance()?.next(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#previous","title":"Previous","text":"<p>Skip to the previous track in the playlist, returns error if <code>CAN_SKIP_TO_PREVIOUS</code> is false</p> <pre><code>AutomixIQ.getInstance()?.previous(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#skip-to-a-track","title":"Skip to a track","text":"<p>Skip to a given track in the playlist based on index.</p> <pre><code>val index = myIndexToSkipTo\n\nAutomixIQ.getInstance()?.skipToTrackAtIndex(index,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#back","title":"Back","text":"<p>Seek to the start of the current track and start playback, returns error if <code>CAN_BACK</code> is false</p> <pre><code>AutomixIQ.getInstance()?.back(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#seek","title":"Seek","text":"<p>Jump to a position in the current track, can be used when playing or paused, returns error if <code>CAN_SEEK</code> is false</p> <pre><code>val seconds = myPositionToSeekTo\n\nAutomixIQ.getInstance()?.seekTo(seconds,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#loop-track","title":"Loop track","text":"<p>Loop the current playing track when it finishes. Use this API to implement single loop playback. </p> <p>For playlist loop, see Replay</p> <pre><code>AutomixIQ.getInstance()?.loopPlayingTrack(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#stop-looping-track","title":"Stop looping track","text":"<p>Stop looping the current playing track. </p> <pre><code>AutomixIQ.getInstance()?.stopLoopingPlayingTrack(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#force-pause-after-playback-of-current-track","title":"Force pause after playback of current track","text":"<p>Force the player to pause after the current playing track finishes. This will prevent AutomixIQ mixing into the next track.</p> <p>This is useful when you would like to play an Ad or do something else in between tracks.</p> <pre><code>AutomixIQ.getInstance()?.playTrackUntilEndThenPause(\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Data-model/","title":"Data model","text":"<p>List of enums and data models used by AutomixIQ to communicate with the client app.</p>"},{"location":"Data-model/#enums","title":"Enums","text":"<ul> <li>AutomixIQLogLevel</li> <li>AutomixIQPlaybackEventType</li> <li>AutomixIQError</li> <li>AutomixIQStatusVariable</li> </ul>"},{"location":"Data-model/#data-models","title":"Data Models","text":"<ul> <li>AutomixIQTunedAuthenticationResponse</li> <li>AutomixIQConfig</li> <li>AutomixIQTrackModel</li> <li>AutomixIQArtistModel</li> <li>AutomixIQPluginMetadataModel</li> <li>AutomixIQStatus</li> <li>AutomixIQWaveformModel</li> </ul>"},{"location":"Data-persistency/","title":"Data persistency","text":"<p>AutomixIQ keeps minimal local files to ensure the SDK runs smoothly.</p>"},{"location":"Data-persistency/#music-metadata-database","title":"Music Metadata Database","text":"<p>In the cache directory dedicated to your app, AutomixIQ maintains a lightweight SQL database <code>music.db</code> to store the metadata of tracks that have been played for subsequent lookup. This file is automatically created on launch if it does not exist.</p>"},{"location":"Data-persistency/#music-analysis-database","title":"Music Analysis Database","text":"<p>In the cache directory dedicated to your app, AutomixIQ keeps a lightweight SQL database <code>paralysis.db</code> to store the analysis data of tracks that have been played. This analysis data is essential to produce beat-matched transitions. This file is automatically created on launch if it does not exist.</p>"},{"location":"Data-persistency/#transition-playback-log","title":"Transition Playback Log","text":"<p>AutomixIQ stores offline transition playback logs for reporting purposes in a SQLite database.</p>"},{"location":"Data-persistency/#clear-cache","title":"Clear cache","text":"<p>To reset persistent analysis storage</p> <pre><code>AutomixIQ.getInstance()?.clearCache()\n</code></pre>"},{"location":"Explicit-lyrics-filter/","title":"Explicit lyrics filter","text":"<p>AutomixIQ can be set to exclude tracks with explicit content. It will automatically skip or transition out of these tracks during playback. </p>"},{"location":"Explicit-lyrics-filter/#check-if-a-track-is-explicit","title":"Check if a track is explicit","text":"<p>An explicit track is identified by the <code>isExplicit</code> flag in its <code>AutomixIQTrackModel</code>. </p> <p>You can mark a track as explicit by setting the <code>isExplicit</code> flag when providing metadata to AutomixIQ.</p>"},{"location":"Explicit-lyrics-filter/#turn-onoff-explicit-filter","title":"Turn on/off explicit filter","text":"<pre><code>val filterExplicit: Boolean = true      // or false\n\nAutomixIQ.getInstance()?.setFilterExplicit(filterExplicit,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Explicit-lyrics-filter/#after-turning-on-explicit-filter","title":"After turning on explicit filter","text":"<ul> <li> <p>If this filtering is enabled when the current track is not explicit, then AutomixIQ will ensure the mix skips over tracks with explicit content by creating a mix between the current track and the first non-explicit track. If no non-explicit track is available, then AutomixIQ will act as if that track is the end of the playlist. If replay is on, then it will look from the beginning of the playlist to find the next non-explicit track.</p> </li> <li> <p>If this filtering is enabled when the current track is explicit, then AutomixIQ will automatically skip to the first available non-explicit track. If no non-explicit track is available, then AutomixIQ will act as if that track is the end of the playlist. If replay is on, then it will look from the beginning of the playlist to find the next non-explicit track.</p> </li> </ul>"},{"location":"Handle-error/","title":"Handle error","text":"<p>Most of the public APIs of AutomixIQ will return an <code>AutomixIQError</code> object through the <code>onError</code> method if any error is encountered.</p> <p>You can find a detailed list of errors here: AutomixIQError Reference.</p>"},{"location":"Install-the-SDK/","title":"Install the SDK","text":""},{"location":"Install-the-SDK/#requirements","title":"Requirements","text":"<p>This SDK requires a minimum of Android API Level 21.</p>"},{"location":"Install-the-SDK/#importing-artifacts","title":"Importing artifacts","text":"<p>AutomixIQ can be brought into your project via our private maven repository.</p> <p>Step 1: Include Tuned Global's maven repository</p> settings.gradle.kts<pre><code>dependencyResolutionManagement {\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     repositories {\n         // ...\n         maven(url = \"https://tunedglobal.pkgs.visualstudio.com/TunedGlobalPublic/_packaging/builds/maven/v1\")\n         // ...\n     }\n}\n</code></pre> <p>Step 2: Add the dependency to your target</p> build.gradle.kts<pre><code>val automixIQVersion = project.findProperty(\"com.tunedglobal.automix.version\")\n\ndependencies {\n    // ...\n    implementation(\"com.tunedglobal:automixiq:$automixIQVersion\")\n    // ...\n}\n</code></pre> <p>Step 3: You should now be able to use AutomixIQ</p> <pre><code>import com.tunedglobal.automix.*\n</code></pre>"},{"location":"Install-the-SDK/#configure-proguard-optional","title":"Configure Proguard (Optional)","text":"<p>If you have any issues finding classes in the SDK, try adding the following to your Proguard configuration.</p> <pre><code>-keep class com.tunedglobal.automixiqinternal.internal.logic.cpp.AMJNILib {\n    public static *;\n    public *;\n}\n</code></pre>"},{"location":"Player-setting/","title":"Player setting","text":"<p>AutomixIQ's player provides a list of settings for enhanced control over playback.</p> <p>Use the <code>AutomixIQ</code> instance to modify player settings.</p> <pre><code>AutomixIQ.getInstance()\n</code></pre> <p>Player setting APIs include:</p> <ul> <li>Playback speed</li> <li>Mute</li> <li>Replay</li> <li>Vinyl start/stop SFX</li> <li>Volume</li> <li>Transition duration</li> <li>Explicit filter</li> </ul>"},{"location":"Player-setting/#playback-speed","title":"Playback speed","text":"<p>Adjust the playback speed with a wider range. The accepted range is 0.5x to 2x of the original playback speed.</p> <ul> <li>Setting the value to 0.5 will play the track at 0.5x speed</li> <li>Setting the value to 1 will play the track at 1x speed</li> <li>Setting the value to 2 will play the track at 2x speed</li> <li>You can set the value anywhere between 0.5 and 2</li> </ul> <pre><code>val playbackSpeed: Float = myPlaybackSpeed      // range from 0.5 to 2\n\nAutomixIQ.getInstance()?.setAutomixPlaySpeed(playbackSpeed,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#volume","title":"Volume","text":"<p>Adjust the volume of the player. This does not change the Android system volume.</p> <pre><code>val volumeNormalised: Float = myVolumeNormalised    // range from 0 to 1\n\nAutomixIQ.getInstance()?.setAutomixVolumeNormalised(volumeNormalised,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#mute","title":"Mute","text":"<p>Mute/unmute the player</p> <pre><code>val muted: Boolean = true   // or false\n\nAutomixIQ.getInstance()?.setMute(muted,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#replay","title":"Replay","text":"<p>Loop the current playlist when it finishes. Use this API to implement playlist loop playback. </p> <p>For single loop, see Loop track</p> <pre><code>val replay: Boolean = true      // or false\n\nAutomixIQ.getInstance()?.setReplay(replay,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#vinyl-startstop-sfx","title":"Vinyl start/stop SFX","text":"<p>The player plays a vinyl start/stop sound effect when resuming or pausing. Use this API to enable/disable this SFX. </p> <p>Note</p> <p>This SFX is turned on by default</p> <pre><code>val enableVinylSFX: Boolean = true      // or false\n\nAutomixIQ.getInstance()?.setVinylStartStopEnabled(enableVinylSFX,\n    onComplete = { automixIQStatus -&gt;\n        // Success\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#transition-duration","title":"Transition duration","text":"<p>Set a preferred transition duration in seconds for the transition between tracks. The SDK will try to generate a smooth transition based on the value set.</p> <pre><code>// range from 0 to 30. If set as 0, the SDK will decide the best transtion duration\nval transitionDurationHint: Float = myTransitionDuration        \n\nAutomixIQ.getInstance()?.setPreferredTransitionDurationSeconds(transitionDurationHint,\n    onComplete = { status -&gt;\n        // Success\n    },\n    onError = { automixIQError, status -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#explicit-filter","title":"Explicit filter","text":"<p>AutomixIQ can be set to exclude tracks with explicit content. It will automatically skip or transition out of these tracks during playback. See Explicit lyrics filter</p>"},{"location":"Turn-Automix-on-and-off/","title":"Turn AutomixIQ on and off","text":"<p>AutomixIQ's player can be turned on or off after initialisation. You need to turn on the player before playing any music.</p> <p>Note</p> <p>If there is another player currently playing music, we suggest pausing the playback once AutomixIQ's player is turned on to prevent competing for audio control. When AutomixIQ's player is turned off, any other player can be resumed.</p>"},{"location":"Turn-Automix-on-and-off/#turn-automixiq-on","title":"Turn AutomixIQ on","text":"<p>You can turn on the player without any tracks, or turn on the player with a list of tracks and its metadata. </p> <p>Note</p> <p>If you start the player without tracks, tracks will need to be provided via the playback control methods later, see Load tracks.</p> Turn on without tracks<pre><code>AutomixIQ.getInstance()?.automixOn(\n    onComplete = { automixIQStatus -&gt; \n        // Player is turned on and is waiting for tracks to be loaded.\n    }, onError = { automixIQError, automixIQStatus -&gt;\n        // Something went wrong, playback did not start\n    }\n)\n</code></pre> <p>Note</p> <p>Please make sure you adhere to the Audio file requirements before loading any tracks to AutomixIQ</p> Turn on with tracks<pre><code>// list of track ids\nval electronicMusicPlaylist = listOf(\"116484855\",\"66906273\",\"120584575\",\"116887896\")\n\n// list of `AutomixIQTrackModel` for tracks\nval cachedMetadata = listOf(trackMetadata1, trackMetadata2, trackMetadata3, trackMetadata4) \n\nAutomixIQ.getInstance()?.automixOn(\n    identifiers = electronicMusicPlaylist,\n    metadata = cachedMetadata,      // nullable, if null and the SDK will call `getTrackMetadata` in `AutomixIQTunedMusicCacheHook` to get metadata\n    playTrackIndex = 0,             // start playback index in playlist\n    seconds = 0,                    // start playback seconds in track\n    autoplay = true,                // start playback immediately or not\n    contextType = \"playlist\",       // for reporting purposes\n    contextId = \"playlist-id\",      // for reporting purposes\n    onComplete = { automixIQStatus -&gt; \n        // Player is turned on and will start playback if autoplay is true\n    }, onError = { automixIQError, automixIQStatus -&gt;\n        // Something went wrong, playback did not start\n    }\n)\n</code></pre>"},{"location":"Turn-Automix-on-and-off/#turn-automixiq-off","title":"Turn AutomixIQ off","text":"<p>Turning off AutomixIQ's player will stop playback</p> <pre><code>AutomixIQ.getInstance()?.automixOff(\n    onComplete = { automixIQStatus -&gt; \n        // Playback should be stopped by now, resume other players if needed.\n        // `automixIQStatus` contains the last status of the player, can be used to provide information to other players to resume playback.\n    },\n    onError = { automixIQError, automixIQStatus -&gt;\n        // Something went wrong, playback did not stop\n    }\n)\n</code></pre> <p>For more information about <code>AutomixIQStatus</code>, see Update UI.</p>"},{"location":"Turn-Automix-on-and-off/#check-onoff-state","title":"Check on/off state","text":"<p>To check whether AutomixIQ's player is turned on</p> <pre><code>AutomixIQ.getInstance()?.on()\n</code></pre>"},{"location":"Update-ui/","title":"Update UI","text":"<p>AutomixIQ provides realtime status update and playback events after the player starts playing. You can register multiple listeners to monitor the status of the player and update your UI accordingly.</p>"},{"location":"Update-ui/#register-status-listener","title":"Register status listener","text":"<p>You can register a status listener any time after the SDK is initialised.</p> <pre><code>AutomixIQ.getInstance()?.addStatusListener(myStatusListener)\n</code></pre>"},{"location":"Update-ui/#unregister-status-listener","title":"Unregister status listener","text":"<p>You can unregister the listener and stop receiving status updates and events when you do not need it any more.</p> <pre><code>AutomixIQ.getInstance()?.removeStatusListener(myStatusListener)\n</code></pre>"},{"location":"Update-ui/#implement-status-listener","title":"Implement status listener","text":"<p>Extend the <code>AutomixIQStatusListener</code> class and implement the required functions as shown below:</p> <ul> <li>onStatusChanged</li> <li>onPlaybackEvent</li> <li>onWaveformDataAvailable</li> </ul> <pre><code>class MyStatusListener: AutomixIQStatusListener {\n\n    override fun onStatusChanged(variables: List&lt;AutomixIQStatusVariable&gt;, status: AutomixIQStatus) {\n        // Monitor status update\n    }\n\n    override fun onPlaybackEvent(type: AutomixIQPlaybackEventType,\n                                 identifier: String?, \n                                 originalSessionId: String?, \n                                 status: AutomixIQStatus?) {\n        // Monitor playback event\n    }\n\n    override fun onWaveformDataAvailable(identifier: String) {\n        // Monitor waveform data availability\n    }\n}\n</code></pre>"},{"location":"Update-ui/#monitor-status-update","title":"Monitor status update","text":"<p>AutomixIQ reports the player status every time it is updated. You can get the current player status from the <code>AutomixIQStatus</code> object and the list of <code>AutomixIQStatusVariable</code> that gets updated since the last time a <code>onStatusChanged</code> is invoked. Use the value of each <code>AutomixIQStatusVariable</code> to update your player UI.</p> <p>For details of each status field, see <code>AutomixIQStatus</code> and <code>AutomixIQStatusVariable</code></p> <pre><code>var latestStatus: AutomixIQStatus? = null\n\noverride fun onStatusChanged(variables: List&lt;AutomixIQStatusVariable&gt;, status: AutomixIQStatus) {\n    // Monitor status update\n\n    this.latestStatus = status\n\n    for (property in variables) {    \n        when (property) {\n            AutomixIQStatusVariable.PLAYING -&gt; {\n                // Change the look and feel of your Play/Pause button here\n                val playing = status.playing\n                // ...\n            }\n            AutomixIQStatusVariable.MIXING -&gt; {}\n            AutomixIQStatusVariable.PLAYING_TRACK_IDENTIFIER -&gt; {}\n            AutomixIQStatusVariable.PLAYING_TRACK_INDEX -&gt; {}\n            AutomixIQStatusVariable.PLAYING_TRACK_CURRENT_TIME -&gt; {\n                // Change your track progress UI here \n                val elapsedTime = status.playingTrackCurrentTime\n                val totalTime = status.playingTrackTotalTime\n                // ...\n            }\n            AutomixIQStatusVariable.PLAYING_TRACK_STREAMING_PROGRESS -&gt; {}\n            AutomixIQStatusVariable.PLAYING_TRACK_TOTAL_TIME -&gt; {\n                // Change your track progress UI here \n                val elapsedTime = status.playingTrackCurrentTime\n                val totalTime = status.playingTrackTotalTime\n                // ...\n            }\n            AutomixIQStatusVariable.CAN_SKIP_TO_PREVIOUS -&gt; {\n                // Change the look and feel of your previous button here\n                val canSkipToPrevious = status.canSkipToPrevious\n                // ...\n            }\n            AutomixIQStatusVariable.CAN_SKIP_TO_NEXT -&gt; {\n                // Change the look and feel of your next button here\n                val canSkipToNext = status.canSkipToNext\n                // ...\n            }\n            AutomixIQStatusVariable.CAN_PLAY_PAUSE -&gt; {\n                // Change the look and feel of your play/pause button here\n                val canPlayPause = status.canPlayPause\n                // ...\n            }\n            AutomixIQStatusVariable.CAN_SEEK -&gt; {}\n            AutomixIQStatusVariable.CAN_REORDER_TRACKS -&gt; {}\n            AutomixIQStatusVariable.REPLAY_ON -&gt; {\n                // Change the look and feel of your replay button here\n                val replayOn = status.replayOn\n                // ...\n            }\n\n            // ...\n            // More `AutomixIQStatusVariable` enums can be found in API reference\n        }\n    }\n}\n</code></pre> <p>A helper function have been created to help you easily get the value of specific <code>AutomixIQStatusVariable</code> from <code>AutomixIQStatus</code></p> Get value for AutomixIQStatusVariable<pre><code>AutomixIQStatus.getValue&lt;T&gt;(AutomixIQStatusVariable)\n</code></pre>"},{"location":"Update-ui/#monitor-playback-event","title":"Monitor playback event","text":"<p>Certain predefined playback events will be returned during playback to help with reporting.</p> <p>For details of each playback event, see <code>AutomixIQPlaybackEventType</code></p> <pre><code>override fun onPlaybackEvent(type: AutomixIQPlaybackEventType,\n                             identifier: String?, \n                             originalSessionId: String?, \n                             status: AutomixIQStatus?) {\n    // Monitor playback event\n    when (type) {\n        AutomixIQPlaybackEventType.TRACK_PLAY_START -&gt; {}\n        AutomixIQPlaybackEventType.TRACK_PLAY_PLAYED_5_SECS -&gt; {}\n        AutomixIQPlaybackEventType.TRACK_PLAY_HEARTBEAT_30_SECS -&gt; {}\n        AutomixIQPlaybackEventType.TRACK_PLAY_START_MIXING_INTO_NEXT -&gt; {}\n        AutomixIQPlaybackEventType.TRACK_PLAY_SKIPPED -&gt; {}\n        AutomixIQPlaybackEventType.TRACK_PLAY_FINISHED -&gt; {}\n        AutomixIQPlaybackEventType.MIX_PLAYBACK_ENDED -&gt; {}\n    }\n}\n</code></pre>"},{"location":"Update-ui/#monitor-waveform-data","title":"Monitor waveform data","text":"<p>When the waveform data for a track is ready, AutomixIQ will invoke <code>onWaveformDataAvailable</code>. See Access waveform data.</p>"}]}