{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PacemakerRadio","text":"<p>Broadcast your playlist, mix, or set along with your voice, to the world. Tune in to other broadcasts and jump in the conversation with comments, or show your support with quick reactions. An interactive UI for AutomixIQ.</p>"},{"location":"#overview","title":"Overview","text":"<p>PacemakerRadio is a framework that exposes an interactive UI to AutomixIQ as well as the capability to leverage Pacemaker Technology to start a broadcast with music from your catalog, your voice and other content, as well as joining available broadcasts, interact with other members of a community or the broacaster, and more.</p> <p>AutomixIQ is included in this framework as well, and it supports the PacemakerRadio technology, but it can also be used standalone.</p> <p>This documentation provides a step-by-step guide on how to get started with using the PacemakerRadio in your application.</p> <p> </p>"},{"location":"API-reference/","title":"API Reference","text":"<p>You can find the documentation of available APIs here: PacemakerRadio API Reference</p>"},{"location":"AutomixIQ/","title":"AutomixIQ","text":"<p>PacemakerRadio works on top of AutomixIQ and exposes the functionality of AutomixIQ. Please note that manipulating playback or queue with AutomixIQ when a user is creating or consuming a radio show may impact the radio show itself and is therefore discouraged.</p> <p>The documentation for AutomixIQ can be found here: AutomixIQ Documentation</p>"},{"location":"Change-log/","title":"Change Log","text":"<p>This is a beta build - No change log available at the moment.</p>"},{"location":"Configure-the-SDK-tuned/","title":"Configure the SDK with Tuned Global backend","text":""},{"location":"Configure-the-SDK-tuned/#overview","title":"Overview","text":"<p>This document explains how to integrate AutomixIQ with your application if it is already using Tuned Global\u2019s backend to access tracks and metadata.</p> <p>To initialise AutomixIQ with Tuned Global's API and services, you need </p> <ul> <li>A store ID and an application ID provided by the Tuned Global team</li> <li>An implementation of the <code>TunedRestHook</code> interface</li> </ul>"},{"location":"Configure-the-SDK-tuned/#implement-your-tunedresthook","title":"Implement your TunedRestHook","text":"<p><code>TunedRestHook</code> is an interface that facilitates communication between the Tuned Global Backend and the AutomixIQ SDK regarding the user's access token and device information. Extend the <code>TunedRestHook</code> class and implement the required functions as shown below:</p> <ul> <li>getAuthenticatedDevice</li> <li>getUniqueDeviceIdentifier</li> <li>onTunedRestTokenExpired</li> </ul> <p>You can find a detailed explanation in API Reference</p> <pre><code>class MyTunedRestHook: TunedRestHook {\n\n    // Return the Tuned API device ID integer\n    override suspend fun getAuthenticatedDevice(uniqueDeviceIdentifier: String): String? {\n        val myTunedDeviceId: String = tunedDeviceId\n        return myTunedDeviceId\n    }\n\n    // Return an ID that can be used to identify a device.\n    // This is typically a randomly generated UUID that persists through app restarts.\n    override fun getUniqueDeviceIdentifier(): String {\n        val uuid: String = myUniqueDeviceIdentifier\n        return uuid\n    }\n\n    // Use the info provided from the parameters to refresh the Tuned user token\n    override suspend fun onTunedRestTokenExpired(uniqueDeviceIdentifier: String,\n                                                 countryCode: String,\n                                                 tunedUserId: String?,\n                                                 oldAccessToken: String?,\n                                                 refreshToken: String?,\n                                                 tokenType: String?): TunedAuthenticationResponse? {\n        // your implementation of refreshing Tuned user token\n        val tunedAuthenticationResponse: TunedAuthenticationResponse? = null\n        withContext(Dispatchers.IO) {\n            suspendCancellableCoroutine { continuation -&gt;\n                refreshToken(refreshToken, tokenType, uniqueDeviceIdentifier) { authToken, tokenType, tokenExpiration, refreshToken -&gt;\n                    val userId = tunedUserId\n                    tunedAuthenticationResponse = TunedAuthenticationResponse(authToken,\n                                                                              tokenType,\n                                                                              tokenExpiration,\n                                                                              refreshToken,\n                                                                              tunedUserId)\n                    continuation.resume(Unit)\n                }\n            }\n        }\n        return tunedAuthenticationResponse\n    }\n}\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#implement-your-radiouilistener","title":"Implement your RadioUIListener","text":"<p><code>RadioUIListener</code> is an interface that provides data required for the Radio UI to function, as well as being responsible for presenting UI PacemakerRadio is not able to do on its own. Extend the <code>RadioUIListener</code> class and implement the required (an optionally, those marked as optinal) methods as shown below:</p> <ul> <li>presentTracklist</li> <li>presentAuthentication</li> <li>presentProfile</li> <li>isTrackLiked</li> <li>setTrackLiked</li> <li>applicationContext</li> </ul> <p>and optionally,</p> <ul> <li>willDismissRadioUI</li> <li> <p>didDismissRadioUI</p> </li> <li> <p>willCloseRadioUI</p> </li> <li>didCloseRadioUI</li> </ul> <pre><code>class MyRadioUIListener: RadioUIListener {\n\n    override fun presentTracklist(context: Context, completion: (tracks: List&lt;AutomixSDKTrackModel&gt;?, playlistName: String?) -&gt; Unit) {\n        // Your implementation for presenting UI that allows to select one or more tracks:\n        // - Feed the track/tracks selected as the second paramenter of the completion block,\n        // - If the tracks selected are part of a playlist, feed the name opf that playlist as the thirsd parameter of the completion block.\n        val context = myActivityContext\n        val myTracklist = MyTracklist(context = myActivityContext, selectedTracksBloc = { tracks, playlistName -&gt;\n            completion(track, playlist, playlistName)\n        })\n        myTracklist.show()\n    }\n\n    override fun presentAuthentication(context: Context, completion: (success: Boolean) -&gt; Unit) {\n        // At a time where PacemakerRadio requires a Tuned User Id, if it does not have one it will require the user to authenticate by calling this function.\n        // Present your login block here\n        val context = myActivityContext\n        val myLoginDialog = MyLoginDialog(context = myActivityContext, onLogin = { success -&gt; \n            completion(success)\n        })\n        myLoginDialog.show()\n    }\n\n    override fun presentProfile(context: Context, identifier: String?, completion: () -&gt; Unit) {\n        // At times, PacemakerRadio will need to present a users' profile. It will do so by calling this function.\n        val context = myActivityContext\n        val myProfileDialog = MyProfileDialog(context = myActivityContext)\n        myProfileDialog.show()\n    }\n\n    override fun isTrackLiked(identifier: String, completion: (isLiked: Boolean) -&gt; Unit) {\n        // At times, PacemakerRadio will need to know if a track is part of the user's \"Liked\" playlist.\n        // It will ask the client application to do so by calling this method.\n        // You can take your time to load the liked playlist if you do not have it around in order to respond.\n        // You can respond synchronously if you do know\n        val likedPlaylist = myLikedPlaylist\n        completion(myLikedPlaylist.contains(identifier))\n    }\n\n    override fun setTrackLiked(\n            identifier: String,\n            liked: Boolean,\n            completion: (error: RadioSDKError?, success: Boolean) -&gt; Unit) {\n        // PacemakerRadio allows for a user to flag/unflag a track as Liked. When that happens, it will call this method.\n        val likedPlaylist = myLikedPlaylist\n        if(liked) {\n            likedPlaylist.add(identifier)\n        } else {\n            likedPlaylist.remove(identifier)\n        }\n    }\n\n    override fun applicationContext(): Context {\n        // At times PacemakerRadio requires the application context to look up resources\n        return applicationContext\n    }\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#initialise-radiosdk-instance","title":"Initialise RadioSDK instance","text":"<p>Create an <code>RadioSDKConfig</code> first. The store and application ID will be provided by the Tuned Global team. You can tweak the PacemakerRadio UI and available feature set by changing flags on the cofing object.</p> <pre><code>val radioConfig =\n    RadioSDKConfig.Builder()\n        .apiKey(myAPIKey)\n        .country(myCountryISO2Code) // Device country code e.g. \"US\", \"AU\"\n        .storeId(myTunedStoreId )\n        .applicationId(myTunedApplicationId)\n        .logLevel(AutomixSDKLogLevel.DEBUG)\n        .build()\n</code></pre> <p>Initialise the RadioSDK instance with the <code>TunedRestHook</code>, <code>RadioUIListener</code> and <code>AutomixSDKConfig</code> created in previous steps. We recommend initialising the SDK once your music background service is up and running.</p> <p>Note</p> <p>PacemakerRadio requires an active internet connection for its initial verification. After this initial setup, it can be initialised offline. However, note that there is a grace period of 7 days, after which an internet connection will be required again for re-verification.</p> <pre><code>    RadioSDK.initialise(applicationContext = applicationContext,\n                        streamingListener = myTunedRestHook,\n                        config = radioConfig,\n                        radioUIListener = radioUIListener,\n                        onComplete = { automixStatus -&gt;\n\n        // The PacemakerRadio public functions can be used from this point onwards :)\n\n        // We can set a music cache hook if we want to support offline playback\n        val musicCacheHook: TunedMusicCacheHook = myMusicCacheHook\n        RadioSDK.getInstance()?.setMusicCacheHook(musicCacheHook)\n\n        // We can add a status listener to get UI updates and play events, you can add as many AutomixSDKStatusListener as you like\n        val automixSDKStatusListener: AutomixSDKStatusListener = myAutomixSDKStatusListener\n        RadioSDK.getInstance()?.addStatusListener(automixSDKStatusListener)\n\n        // ...\n    }, onError = { automixSDKError, automixSDKStatus -&gt; \n        // This means you do not have permission to use AutomixIQ or there is no internet connection when required.\n        return\n    })\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#implement-tunedmusiccachehook-optional","title":"Implement TunedMusicCacheHook (Optional)","text":"<p>PacemakerRadio supports offline playback using local music data. You can implement the <code>TunedMusicCacheHook</code> to</p> <ul> <li>provide track metadata and cached audio data,</li> <li>extract audio data downloaded by PacemakerRadio</li> <li>monitor the download progress</li> </ul> <p>This approach enhances efficiency and prevents PacemakerRadio from having to request this data from Tuned Global\u2019s API if they are already available. This also enables offline playback when all the required data is available locally. </p> <p>Implement the <code>TunedMusicCacheHook</code> and add it to the SDK after initialisation. You can find a detailed explanation in API Reference</p> SetMusicCacheHook<pre><code>RadioSDK.getInstance()?.setMusicCacheHook(MyMusicCacheHook())\n</code></pre> MyMusicCacheHook<pre><code>public class MyMusicCacheHook: TunedMusicCacheHook {\n\n    // Provide the track metadata. For offline playback, this is required if the metadata is not loaded when playing tracks.\n    override fun getTrackMetadata(trackId: String?): AutomixSDKTrackModel? {\n        // If the track is not cached, return null and PacemakerRadio will try to fetch it.\n        if (!isTrackCached(trackId)) {\n            return null\n        }\n        return metadataForTrack(trackId)\n    }\n\n    // Provide the cached audio data. For offline playback, this is required.\n    override fun getCachedTrack(trackId: String): ByteArray? {\n        // If the track is not cached, return null and PacemakerRadio will try to stream it.\n        if (!isTrackCached(trackId)) {\n            return null\n        }\n\n        return rawAudioDataForTrack(trackId)\n    }\n\n    // PacemakerRadio will \n    // - stream and download the tracks when they are not provided from `getCachedTrack` and call this method once the download for each track has completed\n    // - use the cached audio data from getCachedTrack and call this method once the data provided is verified for each track\n    override fun onTrackDownloadCompeleted(trackId: String, data: ByteArray) {\n        cacheTrack(trackId, data)\n    }\n\n    // Monitor the download progress (0 to 1)\n    override fun onTrackDownloadProgressChanged(trackId: String, progress: Float) {\n        updateTrackBufferingProgress(trackId, progress)\n    }\n}\n</code></pre> <p>Note</p> <p>If the byte data for a track provided through <code>getCachedTrack</code> does not fit the Audio file requirements. PacemakerRadio will try to stream the track from the connected backend.</p>"},{"location":"Configure-the-SDK-tuned/#implement-automixsdkstatuslistener-optional","title":"Implement AutomixSDKStatusListener (Optional)","text":"<p>The <code>AutomixSDKStatusListener</code> is responsible for updating your player\u2019s UI, please refer to Update UI</p>"},{"location":"Configure-the-SDK-tuned/#check-initialised-state","title":"Check initialised state","text":"<p>To check whether PacemakerRadio is initialised </p> <pre><code>RadioSDK.getInstance()?.initialised()\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#shut-down","title":"Shut down","text":"<p>To shut down PacemakerRadio</p> <pre><code>RadioSDK.terminate()\n</code></pre> <p>After you have terminated the SDK, you will need to reinitialise if you want to use PacemakerRadio again.</p>"},{"location":"Data-model/","title":"Data model","text":"<p>List of enums and data models used by PacemakerRadio to communicate with the client app.</p>"},{"location":"Data-model/#enums","title":"Enums","text":"<ul> <li>RadioSDKError</li> </ul>"},{"location":"Data-model/#data-models","title":"Data Models","text":"<ul> <li>AutomixSDKList</li> <li>AutomixSDKListItem</li> <li>AutomixSDKUser</li> <li>AutomixSDKMixtape</li> <li>AutomixSDKMixtapeCounters</li> <li>AutomixSDKMixtapeLite</li> <li>AutomixSDKMixtapeTrack</li> <li>AutomixSDKMixtapeTrackImage</li> <li>AutomixSDKWaveformBlob</li> <li>SocialRestAPIConfig</li> </ul>"},{"location":"Get-available-broadcasts/","title":"Get available broadcasts","text":"<p>When you want to fetch a list of currently available live shows as paged request, you use this function as shown below:</p> <ul> <li>getLiveShows</li> </ul> Get available broadcasts<pre><code>class MyApplicationActivity : AppCompatActivity() {\n\n    ...\n    fun getShows() {\n        val limit: Int = 10             // Get a total of 10 shows\n        val start: Int = 0              // Get the first shows\n        RadioSDK.getInstance())?.getLiveShows(limit = limit, start = start,\n                                              onComplete = { liveShows -&gt;\n            // Present the shows on your UI\n            val myLiveShows = myLiveShows\n            myLiveShows.add(liveShows)\n            if(liveShows.size &lt; limit) {\n                // There are more shows available!\n                getNextLiveShowsPage()\n            }\n        },\n        onError = { error -&gt;\n            Log.i(\"MyLog\", \"Failed to get live shows\")\n        })\n    }\n    ...\n}\n</code></pre>"},{"location":"Handle-error/","title":"Handle error","text":"<p>Most of the public APIs of PacemakerRadio will return an <code>AutomixSDKError</code> or a <code>RadioSDKError</code> object through the <code>onError</code> method if any error is encountered.</p> <p>You can find a detailed list of errors here: AutomixSDKError Reference and RadioSDKError Reference.</p>"},{"location":"Install-the-SDK/","title":"Install the SDK","text":""},{"location":"Install-the-SDK/#requirements","title":"Requirements","text":"<p>This SDK requires a minimum of Android API Level 21.</p>"},{"location":"Install-the-SDK/#importing-artifacts","title":"Importing artifacts","text":"<p>PacemakerRadio can be brought into your project via our private maven repository.</p> <p>Step 1: Include Tuned Global's maven repository</p> settings.gradle.kts<pre><code>dependencyResolutionManagement {\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     repositories {\n         // ...\n         maven(url = \"https://tunedglobal.pkgs.visualstudio.com/TunedAutomix.Android.Releases/_packaging/AutoMixAndroidFeed/maven/v1\")\n         // ...\n     }\n}\n</code></pre> <p>Step 2: Add the dependency to your target</p> build.gradle.kts<pre><code>// Please check Tuned Global's maven repository for the latest available version\nval pacemakerRadioVersion = myPacemakerRadioVersion // 0.10.4\n\ndependencies {\n    // ...\n    implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n    implementation(\"org.greenrobot:eventbus:3.3.1\")\n    implementation(\"com.tunedglobal:radiosdk:$pacemakerRadioVersion\")\n    // ...\n}\n</code></pre> <p>Step 3: You should now be able to use PacemakerRadio</p> <pre><code>import com.tunedglobal.radio.*\n</code></pre>"},{"location":"Install-the-SDK/#configure-proguard-optional","title":"Configure Proguard (Optional)","text":"<p>If you have any issues finding classes in the SDK, try adding the following to your Proguard configuration.</p> <pre><code># Automix SDK\n-keep class com.tunedglobal.automix.logic.cpp.AMJNILib  {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.nativewidgets.NativeWidgetsHelper {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.notifications.NotificationsHelper {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.DialogsHelper  {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.ImageHelper  {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.LocalisationHelper {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.RadioUI {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.SamplePlayerHelper {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.SocialLayerHelper {\n    public static *;\n    public *;\n}\n-keep class com.tunedglobal.radio.logic.cpp.TextRenderHelper {\n    public static *;\n    public *;\n}\n</code></pre>"},{"location":"Join-a-broadcast/","title":"Join a broadcast","text":"<p>When you want to join an existing radio broadcast to listen to and interact with it, you use this function as shown below:</p> <ul> <li>joinLiveMixtape</li> </ul> <p>This interface will present the live show and play it, and also provides UI elements to minimise or exit the live session.</p> Join a broadcast<pre><code>class MyApplicationActivity : AppCompatActivity() {\n\n    ...\n    fun onJoinLiveMixtapeButtonPressed(indentifier: String) {\n        val context = this\n        RadioSDK.getInstance()?.joinLiveMixtape(context = context,\n                                                identifier = identifier,\n                                                onComplete = { intent -&gt; \n            startActivity(intent)\n        }, onError = { error -&gt; \n            Log.i(\"MyLog\", \"RadioSession failed to join\")\n        })\n    }\n    ...\n}\n</code></pre> <p>When you want to programatically force-end a radio session the user is listening to, use this function as shown below:</p> <ul> <li>endRadioSession</li> </ul> End a broadcast<pre><code>class MyApplicationActivity : AppCompatActivity() {\n\n    ...\n    fun onEndRadioSessionButtonPressed() {\n        RadioUI.instance.endRadioSession()\n    }\n    ...\n\n}\n</code></pre>"},{"location":"Moderation/","title":"Moderation","text":"<p>PacemakerRadio offers moderation of content by allowing the user to report inapropriate mixtapes or users. To do so, you use</p> <ul> <li>reportUser</li> <li>reportMixtape</li> </ul> Reporting inapropriate content<pre><code>class MyApplicationActivity : AppCompatActivity() {\n\n    ...\n    fun onReportUserButtonPressed(identifier: String) {\n        RadioSDK.getInstance()?.reportUser(identifier, onComplete = {\n        },\n        onError = { error, status -&gt; \n            Log.i(\"MyLog\", \"RadioSession failed to report a user\")\n        })\n    }\n\n    fun onReportMixtapeButtonPressed(identifier: String) {\n        RadioSDK.getInstance()?.reportMixtape(identifier, onComplete = {\n        },\n        onError = { error, status -&gt; \n            Log.i(\"MyLog\", \"RadioSession failed to report a user\")\n        })\n    }\n    ...\n\n}\n</code></pre> <p>PacemakerRadio also offers the possibility of sending users a notification. To do so, you use </p> <ul> <li>notifyFollowers</li> </ul> Notifying users<pre><code>class MyApplicationActivity : AppCompatActivity() {\n\n    ...\n    fun notifyFollowers(identifier: String, title: String, body: String, objectType: String?, objectId: String?) {\n        RadioSDK.getInstance()?.notifyFollowers(userIdentifier = identifier, title, body, objectType, objectId, onComplete = {\n        },\n        onError = { error -&gt; \n            Log.i(\"MyLog\", \"RadioSession failed to notify users\")\n        })\n    }\n    ...\n\n}\n</code></pre>"},{"location":"Start-a-broadcast/","title":"Start a broadcast","text":"<p>When you want to start a radio broadcast, you use this function as shown below:</p> <ul> <li>startRadioSession</li> </ul> <p>You can either start a radio session with a bunch of identifiers, or an empty one. This function will not make the user go live with his or her session inmediately, instead it will create a draft he or she can edit or curate first.</p> <p>This function provides an Activity with the PacemakerRadio UI. Starting that activity will allow the user to curate that playlist, and when ready, go \"Live\" with it.</p> Start a broadcast<pre><code>class MyApplicationActivity : AppCompatActivity() {\n\n    ...\n    fun onStartRadioSessionButtonPressed() {\n        val context = this\n        val identifiers: List&lt;String&gt;? = myIdentifiers                   // Can be null\n        val metadata: List&lt;AutomixSDKTrackModel&gt;? = null                 // Populate if available\n        RadioSDK.getInstance()?.startRadioSession(context = context,\n                                                  identifiers = identifiers,\n                                                  metadata = metadata,\n                                                  playTrackIndex = 0, seconds = 0F, autoplay = true,\n                                                  contextType = null,\n                                                  contextId = null,\n                                                  onComplete = { intent, status -&gt; \n            startActivity(intent)\n        },\n        onError = { error, status -&gt; \n            Log.i(\"MyLog\", \"RadioSession failed to create\")\n        })\n    }\n    ...\n\n}\n</code></pre> <p>When you want to programatically force-end a radio session the user has created, use this function as shown below:</p> <ul> <li>endRadioSession</li> </ul> End a broadcast<pre><code>class MyApplicationActivity : AppCompatActivity() {\n\n    ...\n    fun onEndRadioSessionButtonPressed() {\n        RadioUI.instance.endRadioSession()\n    }\n    ...\n\n}\n</code></pre>"}]}